ICS 53
HW 9
1. I will provide you a working single-threaded client/server to use as a starting point for your solutions this week here and the files are now readable (you must each change the PORT in the Makefile to your own student ID port you used for HW 8 or you will get conflicts with other students).  Note each server will be a modification of this same server program and the client will be a modification of the client I provide you.  I got carried away with the client and it is finished.  You may solve HW9 in pairs (with one partner from your lab) or solo (by yourself).  If you do it in pairs, submit one homework with both your names and IDs in the report.
2. I wrote a multi-threaded client that will do a remote copy (from server machine to client machine) of files from your servers below.  Ensure the client creates 10 threads to read files, then start a timer, have each of the 10 threads copy all the (approximately 20) files in the list of files to copy (listed in the start I provide), then stop the timer, and report the elapsed user time.  Each thread should copy the files into a directory with a unique name, such as ./Thread_1, ./Thread_2, etc. where the integer is the number of the thread (so yours will have 1 through 10).   You must change the list of files to the same files we used for testing HW8 - the .jar files located in /usr/share over 200 blocks.  Edit the list of files to be these same files.
3. (75 pts) Write the three multi-threaded servers below.
   1. Thread Per Request Server 1 (25 pts) Write a multi-threaded server that delivers files to clients above using thread per connection (or request as there will be only one file requested per connection).  It will create a new thread for each client request. Note there are 10 threads each requesting a copy of 20 files, so there will be 200 threads created in this testing example.
   2. Thread Pool Server 2 (25 pts) Write a multi-threaded server that delivers files to clients above, but use a synchronized queue between the thread that reads requests from the clients and a pool of 5 threads that process client requests. Note all the syncyronization should happen in the queue.  Here is one implementation of the queue using pthreads and two mutex.  The important functions are putOnQ and getOffQ. Here is another that uses cond variables.
   3. Leader-Follower Server 3 (25 pts) Write a multi-threaded server that delivers files to clients above, but use a thread pool using leader-follower with 5 threads in the pool.
1. (25 pts) Measure the performance of each of your three servers using your single multi-threaded client.  The measurements should be done on the client side using the timer class you used earlier in this class. Time the effort to copy the entire set of 10 threads X 20 files each = 200 files. Run both your server and client on odin.ics.uci.edu.
2. Be sure to test your copy program to ensure it is making correct copies.  I suggest you copy the remote /usr/share/dict/linux.words, then use diff to compare your local copy to the local file in /usr/share/dict/linux.words to ensure the entire file was copied correctly from the remote machine.
NOTE: Periodically check your processes from the shell with ps aux, and kill any run-away processes with kill -9 pid.
What to submit: Your programs and your Makefile and a report which shows your programs compile, run, and produce timed output. Also state in your report which design gave the best performance and why.